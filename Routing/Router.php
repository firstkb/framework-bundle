<?php

namespace Firstkb\FrameworkBundle\Routing;

use Firstkb\FrameworkBundle\Core\Config;
use Firstkb\FrameworkBundle\Http\Request;
use Firstkb\FrameworkBundle\Http\Response;
use Firstkb\FrameworkBundle\Template\Template;
use Exception;

class Router
{

    /**
     * The root path of the application
     *
     * @var string
     */
    protected $rootPath;

    /**
     * The current environment (either 'dev' or 'prod')
     *
     * @var string
     */
    protected $environment;

    /**
     * An array of registered routes, indexed by HTTP method
     *
     * @var array
     */
    protected $routes = [
        'GET' => [],
        'POST' => [],
        'PUT' => [],
        'DELETE' => [],
        'UPDATE' => [],
        'PATCH' => [],
        'map' => []
    ];

    /**
     * The HTTP method of the current request
     *
     * @var string
     */
    protected $httpMethod;

    /**
     * The current URI being requested
     *
     * @var string
     */
    protected $currentUri;

    /**
     * The server base path for the application
     *
     * @var string
     */
    protected $serverBasePath;

    /**
     * The Request object for the current request
     *
     * @var Request
     */
    protected $request;

    /**
     * The Config object for the application
     *
     * @var Config
     */
    protected $config;

    /**
     * The Template object for the application
     *
     * @var Template
     */
    protected $template;

    /**
     * An array of locale preferences
     *
     * @var array
     */
    protected $localePref;

    /**
     * The current Route being requested
     *
     * @var array
     */
    protected $currentRoute = [];

    /**
     * Constructor.
     *
     * @param string $rootPath The root path of the application.
     * @param string $environment The environment in which the application is running (e.g. 'prod' or 'dev').
     * @param Config $config An instance of the Config class containing the application configuration.
     * @param Request $request An instance of the Request class containing the HTTP request data.
     */
    public function __construct(string $rootPath, string $environment, Config $config, Request $request)
    {
        $this->rootPath = $rootPath;
        $this->environment = $environment;
        $this->config = $config;
        $this->request = $request;

        $this->getRoutes();
    }

    /**
    * Run the router to find and execute the matching route.
    * @param Template $template The template object to use for rendering the response.
    * @return Response|string The response generated by the matched route.
    */
    public function runRoute(Template $template)
    {
        $this->template = $template;
        $this->httpMethod = mb_strtoupper($this->getRequestMethod());
        $this->currentUri = $this->getCurrentUri();
        return $this->searchRoute();
    }

    /**
     * Get the path for a named route with given parameters.
     *
     * @param string $name The name of the route to get.
     * @param array $params The parameters to use in the path.
     *
     * @return string The path for the named route.
     * @throws Exception If the named route is not found, or if the parameters are invalid.
     */
    public function getRoute(string $name, array $params = []) : string
    {
        // Check if the named route exists and get its HTTP methods.
        $methods = isset($this->routes['map'][$name]) ? $this->routes['map'][$name] : false;
        // Check if the named route exists for the requested HTTP method.
        if (isset($methods[0]) && isset($this->routes[$methods[0]][$name])) {
            $route = $this->routes[$methods[0]][$name];

            // Set the locale parameter to the current request's locale, if needed.
            if (in_array('_locale', $route['params']) && !isset($params['_locale'])) {
                $params['_locale'] = $this->request->getLocale();
            }

            // Check if the number of parameters matches the number of required parameters for the route.
            if (count($params) != count($route['params'])) {
                throw new Exception("Only supports parameters [".implode(', ', $route['params'])."] for route {$name}", 500);
            }

            // Replace the locale parameter with the corresponding locale path segment.
            $localeArray = $this->request->getLocaleArray();
            if (isset($params['_locale']) && isset($localeArray[$params['_locale']])) {
                $params['_locale'] = str_replace('/', '', $localeArray[$params['_locale']]);
            }

            // Validate and replace the path parameters in the route path.
            try {
                $path = $this->validatePathParams($route['path'], $params);
                return $path;
            } catch (Exception $e) {
                throw new Exception($e->getMessage(), 500);
            }

        }

        // Throw an exception if the named route is not found.
        throw new Exception("Route {$name} not found", 500);

    }

    /**
     * Validates path parameters by replacing them with actual values from the given parameter array.
     *
     * @param string $path The path containing the parameters in the format {paramName:paramType}.
     * @param array $params An associative array of parameter names and values.
     * @return string The path with actual parameter values.
     *
     * @throws Exception if the parameter is not found in the given parameters array, or if it has an invalid type.
     */
    protected function validatePathParams(string $path, array $params) : string
    {
        // Find all parameters in the path string and replace them with their actual values from the parameter array.
        preg_match_all("/{([^:}]+)(:([^}]+))?}/", $path, $matches, PREG_SET_ORDER);
        foreach ($matches as $match) {
            $paramName = $match[1];
            $paramType = $match[3] ?? null;

            // Check if the parameter exists in the given array.
            if (!array_key_exists($paramName, $params)) {
                throw new Exception(sprintf(
                    'Parameter "%s" not found in the given parameters array.',
                    $paramName
                ));
            }

            // Check if the parameter type is valid.
            $paramValue = $params[$paramName];
            if ($paramType === 'int') {
                if (!is_numeric($paramValue) || (int) $paramValue != $paramValue) {
                    throw new Exception(sprintf(
                        'Parameter "%s" should be an integer.',
                        $paramName
                    ));
                }
            } elseif ($paramType === 'string') {
                if (!ctype_alpha($paramValue)) {
                    throw new Exception(sprintf(
                        'Parameter "%s" should be a string consisting only of alphabetic characters.',
                        $paramName
                    ));
                }
            }

            // Replace the parameter in the path string with its actual value.
            $path = preg_replace('#/+#', '/', str_replace($match[0], $paramValue, $path));
        }

        return $path;
    }

    /**
    * Returns the current request method, taking into account method override headers.
    * @return string The current request method.
    */
    protected function getRequestMethod() : string
    {
        $method = $this->request->server->get('REQUEST_METHOD');

        if ($_SERVER['REQUEST_METHOD'] == 'HEAD') {
            ob_start();
            $method = 'GET';
        } // If it's a POST request, check for a method override header
        elseif ($this->request->server->get('REQUEST_METHOD')) {
            $headers = $this->getRequestHeaders();
            if (isset($headers['X-HTTP-Method-Override']) && in_array($headers['X-HTTP-Method-Override'], array('PUT', 'DELETE', 'PATCH'))) {
                $method = $headers['X-HTTP-Method-Override'];
            }
        }
        return $method;
    }

    /**
     * Returns an array with all HTTP request headers.
     * @return array All HTTP request headers.
     */
    protected function getRequestHeaders() : array
    {
        $headers = array();
        // If getallheaders() is available, use that
        if (function_exists('getallheaders')) {
            $headers = getallheaders();
            // getallheaders() can return false if something went wrong
            if ($headers !== false) {
                return $headers;
            }
        }
        // Method getallheaders() not available or went wrong: manually extract 'm
        foreach ($_SERVER as $name => $value) {
            if ((substr($name, 0, 5) == 'HTTP_') || ($name == 'CONTENT_TYPE') || ($name == 'CONTENT_LENGTH')) {
                $headers[str_replace(array(' ', 'Http'), array('-', 'HTTP'), ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))))] = $value;
            }
        }
        return $headers;
    }

    /**
     * Returns the current URI of the request, without the base path and query string.
     *
     * @return string The current URI of the request.
     */
    protected function getCurrentUri() : string
    {
        $uri = substr($this->request->server->get('REQUEST_URI'), strlen($this->getBasePath()));
        if (strstr($uri, '?')) {
            $uri = substr($uri, 0, strpos($uri, '?'));
        }
        return '/'.$uri;
    }

    /**
     * The function returns the base path of the application on the server using information from the Request class
     * @return string Base path of the application
     */
    protected function getBasePath() : string
    {
        if ($this->serverBasePath === null) {
            $this->serverBasePath = implode('/', array_slice(explode('/', $this->request->server->get('SCRIPT_NAME')), 0, -1)).'/';
        }
        return $this->serverBasePath;
    }

    /**
     * Searches the routing map for a matching route for the current request and returns its response.
     * If no match is found, displays the 404 page.
     *
     * @throws Exception If the controller or method specified in the route is not found or if an error occurs while running the route
     *
     * @return Response The response returned by the controller method specified in the route, or false if no match is found
     * @throws Exception If the "route not found" controller method is not set in the configuration.
     */
    protected function searchRoute()
    {
        // Check if there is a route matching the current request method
        if (isset($this->routes[$this->httpMethod]))
        {
            $currentUri = $this->currentUri != '/' ? $this->currentUri : '/';
            $routingMap = $this->routes[$this->httpMethod];

            // Loop through all routes for the current request method to find a match
            foreach ($routingMap as $arRoute)
            {
                // Check if the current URI matches the route's regex
                if (preg_match_all($arRoute['regex'], $currentUri, $matches)) {

                    // Check if there's a redirect URL needed (if the URI should have a trailing slash, for example)
                    $redirectUrl = false;
                    if (substr($arRoute['path'], -1) == '/' && substr($currentUri, -1) != '/') {
                        $redirectUrl = $currentUri . '/';
                    } elseif (substr($arRoute['path'], -1) != '/' && substr($currentUri, -1) == '/') {
                        $redirectUrl = rtrim($currentUri, '/') . '';
                    }

                    // If a redirect URL is needed, redirect and exit
                    if ($redirectUrl) {
                        if (!empty($this->request->server->get('QUERY_STRING'))) {
                            $redirectUrl .= '?' . $this->request->server->get('QUERY_STRING');
                        }
                        header('HTTP/1.1 301 Moved Permanently');
                        header('Location: ' . $redirectUrl);
                        exit();
                    }

                    // set current match route array
                    $this->currentRoute = $arRoute;

                    // If there's a match, get the controller and method from the route and call it with the URI parameters
                    $methodPath = $arRoute['classNamespace'].'\\'.$arRoute['className'];
                    $classFunction = $arRoute['function'];
                    $controller = new $methodPath($this->request, $this, $this->template);
                    $params = [];
                    if (is_array($arRoute['params'])) {
                        foreach ($arRoute['params'] as $param) {
                            if (in_array($param, array_keys($matches))) {
                                $params[$param] = isset($matches[$param][0]) ? $matches[$param][0] : '';
                            }
                        }
                    }

                    // Set the locale if specified in the URI
                    if (isset($params['_locale'])) {
                        $this->request->setLocale($params['_locale']);
                        unset($params['_locale']);
                    }

                    // Call the controller method with the parameters and catch any exceptions
                    try {
                        $response = $controller->$classFunction(...$params);
                    } catch (Exception $e) {
                        throw new Exception($e->getMessage(), 500);
                    }

                    return isset($response) ? $response : false;
                }
            }
        }

        // If no matching route was found, display the 404 page
        return $this->displayRouterNotFound();
    }

    /**
     * If no matching route was found, display the "route not found" page.
     *
     * @return Response The response from the "route not found" page controller method, if set in the configuration.
     * @throws Exception If the "route not found" controller method is not set in the configuration.
     */
    protected function displayRouterNotFound()
    {
        // Get the "route not found" controller method from the configuration.
        $controllerNotFound = $this->config->get('route_not_found');

        // If the "route not found" controller method is set, execute it.
        if (!empty($controllerNotFound)) {
            // Get the class name and method name from the configuration setting.
            list($className, $methodName) = explode('::', $controllerNotFound);

            // Instantiate the controller.
            $controller = new $className($this->request, $this, $this->template);

            try {
                // Call the "route not found" controller method and get the response.
                $response = $controller->$methodName();
            } catch (Exception $e) {
                // If an exception occurs while calling the controller method, throw an exception with the error message.
                throw new Exception($e->getMessage(), 500);
            }

            // Return the response from the "route not found" controller method.
            return isset($response) ? $response : false;
        }

        // If the "route not found" controller method is not set in the configuration, throw an exception with an error message.
        throw new Exception('[route_not_found] in config not set', 500);
    }


    /**
     * Get the routes by either generating them or retrieving from the cache.
     *
     * If the cache file doesn't exist or the environment is in 'dev' mode, regenerate the routes using setRoutes().
     * Otherwise, retrieve the routes from the cache.
     */
    protected function getRoutes()
    {
        // If the cache file doesn't exist or the environment is in 'dev' mode, regenerate the routes using setRoutes().
        if (!$this->checkCacheFile() || $this->environment == 'dev') {
            $this->setRoutes();
        }
        // Otherwise, retrieve the routes from the cache.
        $this->routes = require($this->rootPath.'/cache/'.$this->environment.'/routes.php');
    }

    /**
     * Checks if the routes cache file exists for the current environment.
     *
     * @return bool Returns true if the routes cache file exists, false otherwise.
     */
    protected function checkCacheFile() : bool
    {
        if (file_exists($this->rootPath.'/cache/'.$this->environment.'/routes.php')) {
            return true;
        }
        return false;
    }

    /**
     * Sets the routes for the router instance.
     * This function gets the route prefix, adds routes from controllers,
     * adds routes from the config file, and saves the routes.
     */
    protected function setRoutes()
    {
        // Collect routes from all controllers
        $this->getPrefixForRoutes();
        $this->addRoutesFromControllers();

        // Add routes from config file
        $this->addRouteFromConfigFile();

        // Save the routes to the cache
        $this->saveRoutes();
    }

    /**
     * Sets the locale prefix for routes.
     * The prefix is constructed from the 'locale' array in the application configuration.
     * The prefix is only added to the routes if the 'locale' array is not empty.
     * Example: /{locale}/about-us
     */
    protected function getPrefixForRoutes()
    {
        $prefArray = $this->config->get('locale');
        if (!empty($prefArray) && is_array($prefArray)) {
            $this->localePref = '/(/(?P<_locale>'.str_replace('/', '', implode('|', array_filter($prefArray))).'))'.(in_array('', $prefArray) ? '?' : '');
        }
    }

    /**
     * Adds routes from the 'config/routes.php' file, if it exists.
     * The routes are added using the 'addRoutesFromConfig' function.
     *
     */
    protected function addRouteFromConfigFile()
    {
        if (file_exists($this->rootPath.'/config/routes.php')) {
            $this->addRoutesFromConfig();
        }
    }

    /**
     * Saves the routes array to a cache file.
     * The cache file is stored in the '/cache' directory and is named 'routes.php'.
     * The cache file is used by the router when the application is in production mode.
     * The routes array is exported using the 'varexport' function.
     *
     */
    protected function saveRoutes()
    {
        file_put_contents($this->rootPath.'/cache/'.$this->environment.'/routes.php', '<?php return ' . $this->varexport($this->routes) . ';');
    }

    /**
     * The addRoutesFromConfig function reads the routes defined in the /config/routes.php configuration file and adds them to the routes list.
     * It first reads the route configuration from the file and then extracts the class name and method name from the "controller" field of the configuration.
     * It then constructs the path, HTTP methods, and route name from the configuration and generates a regex pattern for the route path.
     *
     * The function checks that the specified controller class and method exist and adds the route to the routes list for each of the specified HTTP methods.
     * Finally, it saves the generated routes to a cache file. If the cache file already exists and the environment is not "dev", it reads the routes from the cache instead of re-generating them.
     */
    protected function addRoutesFromConfig()
    {
        // Get routes from the config file
        $configRoutes = require($this->rootPath.'/config/routes.php');

        // Loop through each route in the config file
        foreach ($configRoutes as $config) {
            $route = [];

            // Check if controller is set and if it has the correct format
            if (!isset($config['controller']) || !preg_match('/::/', $config['controller'])) {
                continue;
            }

            // Get class name and method name from the controller string
            list($className, $methodName) = explode('::', $config['controller']);

            // Get the namespace and file path for the controller class
            $classNamespace = substr($config['controller'], 0, strrpos($config['controller'], '\\'));
            $classFile = str_replace('\\', '/', $className) . '.php';
            $classFile = $this->rootPath . '/' . str_replace('App', 'src', $classFile);
            $className = basename($classFile, ".php");

            // Set the route path, methods, name and function
            $route['path'] = !isset($config['path']) ? '/' : $config['path'];
            $route['methods'] = !isset($config['methods']) ? ['GET'] : $config['methods'];
            $route['name'] = !isset($config['name']) ? $methodName : $config['name'];
            $route['function'] = $methodName;

            // Convert the route path to a regex pattern and get the route params
            $pathToreg = $this->routePathToRegex($route['path']);
            $route['regex'] = isset($pathToreg['regex']) ? $pathToreg['regex'] : '';
            $route['params'] = isset($pathToreg['params']) ? $pathToreg['params'] : '';

            // Set the controller class name, namespace and file path
            $route['className'] = $className;
            $route['classNamespace'] = $classNamespace;
            $route['classFile'] = $classFile;

            // Check if the controller file exists
            if (!file_exists($classFile)) {
                throw new Exception("Controller Not found ".$config['controller'], 500);
            }

            // Get the code for the controller class
            $classCode = @file_get_contents($classFile);

            // Check if the controller class exists
            if (!preg_match('/class\s+' . $className . '\s+(extends\s+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)?\s*{.*?}/s', $classCode, $matches)) {
                throw new Exception('Class '.$className.' not found!', 500);
            }

            // Check if the controller method exists
            if (!method_exists($classNamespace.'\\'.$className,$methodName)) {
                throw new Exception('Class '.$className.' method '.$methodName.' not found!', 500);
            }

            // Add the route to the routes map
            $this->routes['map'][$route['name']] = $route['methods'];

            // Add the route to each method in the methods array
            foreach ($route['methods'] as $methods) {
                $this->routes[$methods][$route['name']] = $route;
                unset($this->routes[$methods][$route['name']]['methods']);
            }

        }
    }


    /**
     * Adds routes from controller classes
     */
    protected function addRoutesFromControllers()
    {
        // Get all PHP files in the src/controllers directory and its subdirectories
        $files = $this->getFilesRecursive($this->rootPath.'/src/controllers');

        // Loop through the files
        foreach ($files as $file) {
            // Parse the file to get an array of route data
            $routeController = $this->parceController($file);
            if (!empty($routeController)) {
                // Loop through the route data and add each route to the routes array
                foreach ($routeController as $arRoute) {
                    // Add the route to the map and to the array of routes for each HTTP method it handles
                    $this->routes['map'][$arRoute['name']] = $arRoute['methods'];
                    $arRoute['classFile'] = $file;
                    foreach ($arRoute['methods'] as $methods) {
                        $this->routes[$methods][$arRoute['name']] = $arRoute;
                        unset($this->routes[$methods][$arRoute['name']]['methods']);
                    }
                }
            }
        }
    }

    /**
     * Recursively gets all files in a directory and its subdirectories
     *
     * @param string $dir The directory to search
     * @return array An array of file paths
     */
    protected function getFilesRecursive(string $dir) : array
    {
        $files = array();
        $items = glob($dir . '/*');
        foreach ($items as $item) {
            if (is_file($item) && pathinfo($item, PATHINFO_EXTENSION) === 'php') {
                $files[] = $item;
            } else if (is_dir($item)) {
                $files = array_merge($files, $this->getFilesRecursive($item));
            }
        }
        return $files;
    }


    /**
     * Parses the given file and returns an array of routes found in the class.
     *
     * @param string $file Path to the PHP class file to parse
     *
     * @return array Array of routes found in the class
     *
     * @throws Exception if the class or a method in the class has invalid syntax or doesn't exist
     */
    protected function parceController(string $file) : array
    {
        $routers = [];
        if (file_exists($file)) {
            $classCode = @file_get_contents($file);
            $className = basename($file, ".php");
            $classNamespace = $this->getNamespaceFromFile($classCode);

            // Match the class definition in the code
            if (!preg_match('/class\s+' . $className . '\s+(extends\s+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)?\s*{.*?}/s', $classCode, $matches)) {
                throw new Exception('Class '.$className.' not found!', 500);
            }

            // Match all the methods with the @Route annotation
            if (preg_match_all('/\s*\/\*\*\s*\n\s+\*\s*@Route\((.*?)\).*?\n\s+\*\/\s*\n\s*(public\s+function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)\s*\((.*?)\))/s', $classCode, $methodsMatches, PREG_SET_ORDER)) {
                foreach ($methodsMatches as $methodMatch) {
                    $routeAnnotation = $methodMatch[1];
                    $methodNameFromRoute = $methodMatch[3];

                    $routeArgs = [];
                    preg_match_all('/(\w+)\s*=\s*(?:"([^"]*)"|([^\s",]+))/', $routeAnnotation, $routeMatches, PREG_SET_ORDER);
                    foreach ($routeMatches as $match) {
                        if ($match[2] !== '') {
                            $routeArgs[$match[1]] = $match[2];
                        } else {
                            $routeArgs[$match[1]] = $match[3];
                        }
                    }

                    // Set defaults if the arguments are not provided in the annotation
                    $routeArgs['path'] = !isset($routeArgs['path']) ? '/' : $routeArgs['path'];
                    $routeArgs['methods'] = !isset($routeArgs['methods']) ? ['GET'] : explode(',', str_replace([' ', '[', ']', '(', ')'], ['', '', '', '', ''], $routeArgs['methods']));
                    $routeArgs['name'] = !isset($routeArgs['name']) ? $methodNameFromRoute : $routeArgs['name'];
                    $routeArgs['function'] = $methodNameFromRoute;

                    // Convert the route path to regex and add it to the route arguments
                    $pathToreg = $this->routePathToRegex($routeArgs['path']);
                    $routeArgs['regex'] = isset($pathToreg['regex']) ? $pathToreg['regex'] : '';
                    $routeArgs['params'] = isset($pathToreg['params']) ? $pathToreg['params'] : '';

                    // Add class and namespace information to the route arguments
                    $routeArgs['className'] = $className;
                    $routeArgs['classNamespace'] = $classNamespace;

                    $routers[] = $routeArgs;
                }
            }
        }

        return $routers;
    }


    /**
     * Get the namespace of a PHP file from its source code.
     * @param string $src The PHP source code.
     * @return string The namespace, or an empty string if no namespace is found.
     */
    function getNamespaceFromFile(string $src) : string
    {
        $pattern = '/^namespace\s+(.*);/m';
        if (preg_match($pattern, $src, $matches)) {
            return $matches[1];
        } else {
            return '';
        }
    }

    /**
     * Convert a route path to a regular expression and extract its parameter names.
     * @param string $path The route path.
     * @return array An array containing the regular expression and parameter names.
     */
    function routePathToRegex(string $path) : array
    {

        $extension = pathinfo($path, PATHINFO_EXTENSION);
        if (empty($extension)) {
            if (substr($path, -1) != '/') {
                $path .= '/?';
            } else {
                $path .= '?';
            }
        } else {
            $path = str_replace('.', '\.', $path);
        }

        $params = [];
        $regex = preg_replace_callback('/{(\w+)(?::(\w+))?}/', function ($matches) use (&$params) {
            $paramName = $matches[1];
            $paramType = isset($matches[2]) ? $matches[2] : 'any';
            switch ($paramType) {
                case 'int':
                    $regex = '(?P<' . $paramName . '>\d+)';
                    break;
                case 'string':
                    $regex = '(?P<' . $paramName . '>[a-zA-Z]+)';
                    break;
                default:
                    if ($paramName == '_locale') {
                        $regex = $this->localePref;
                    } else {
                        $regex = '(?P<' . $paramName . '>[\w-]+)';
                    }
            }
            $params[] = $paramName;
            return $regex;
        }, $path);
        return ['regex' => '#^' . preg_replace('#//#', '', $regex) . '$#', 'params' => $params];
    }

    /**
     * Export a variable as a string of PHP code.
     * @param array $expression The variable to be exported.
     * @return string The PHP code representing the variable.
     */
    protected function varexport(array $expression) : string
    {
        $export = var_export($expression, true);
        $patterns = [
            "/array \(/" => '[',
            "/^([ ]*)\)(,?)$/m" => '$1]$2',
            "/=>[ ]?\n[ ]+\[/" => '=> [',
            "/([ ]*)(\'[^\']+\') => ([\[\'])/" => '$1$2 => $3',
        ];
        return preg_replace(array_keys($patterns), array_values($patterns), $export);
    }
}